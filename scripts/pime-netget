#!/bin/bash
# pime-netget v2.2 - Enhanced connection diagnostics

VERSION="2.2"
USER_AGENT="pime-netget/$VERSION"
DEFAULT_TIMEOUT=30

show_help() {
    cat <<EOF
pime-netget v$VERSION - Robust HTTPS client with diagnostics

Usage:
  pime-netget [options] <url>
  
Options:
  -o FILE      Write output to FILE
  -L           Follow redirects
  -v           Verbose mode (shows connection details)
  -k           Skip SSL verification
  --test       Test connection without downloading
  --help       Show this help
EOF
}

diagnose_connection() {
    local host="$1"
    local port="$2"
    
    echo "Running connection diagnostics for $host:$port..." >&2
    
    # 1. Check DNS resolution
    if ! host "$host" &>/dev/null; then
        echo "DNS Error: Could not resolve $host" >&2
        return 1
    fi
    
    # 2. Test basic TCP connection
    if ! timeout 2 bash -c "cat < /dev/null > /dev/tcp/$host/$port" 2>/dev/null; then
        echo "Connection Error: Cannot reach $host:$port (TCP failed)" >&2
        return 1
    fi
    
    # 3. Test SSL handshake
    local ssl_test=$(echo | openssl s_client -connect "$host:$port" -servername "$host" 2>&1)
    if [[ "$ssl_test" == *"Certificate chain"* ]]; then
        echo "SSL Info: Valid certificate found" >&2
    elif [[ "$ssl_test" == *"verify error"* ]]; then
        echo "SSL Warning: Certificate verification failed" >&2
    else
        echo "SSL Error: Handshake failed" >&2
        return 1
    fi
    
    return 0
}

netget() {
    local url="$1"
    local output_file="$2"
    local follow_redirects=0
    local verbose=0
    local insecure=0
    local test_only=0
    
    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case "$1" in
            -o) output_file="$2"; shift 2 ;;
            -L) follow_redirects=1; shift ;;
            -v) verbose=1; shift ;;
            -k) insecure=1; shift ;;
            --test) test_only=1; shift ;;
            --help) show_help; return 0 ;;
            *) url="$1"; shift ;;
        esac
    done

    [ -z "$url" ] && { show_help; return 1; }

    # Parse URL
    if [[ ! "$url" =~ ^https:// ]]; then
        echo "Error: Only HTTPS URLs are supported (must start with https://)" >&2
        return 1
    fi

    local host_port="${url#https://}"
    host_port="${host_port%%[/?]*}"
    local path="/${url#https://$host_port/}"
    
    local host="${host_port%:*}"
    local port="${host_port##*:}"
    [ "$port" = "$host_port" ] && port=443

    # Run diagnostics
    if [ $verbose -eq 1 ] || [ $test_only -eq 1 ]; then
        if ! diagnose_connection "$host" "$port"; then
            return 1
        fi
        [ $test_only -eq 1 ] && return 0
    fi

    # Prepare SSL options
    local ssl_opts="-quiet"
    [ $insecure -eq 1 ] && ssl_opts+=" -verify_quiet -verify_return_error"

    # Create temporary files
    local tmp_dir=$(mktemp -d)
    local response_file="$tmp_dir/response"
    local error_file="$tmp_dir/error"
    trap 'rm -rf "$tmp_dir"' EXIT

    # Make the request
    {
        printf "GET %s HTTP/1.1\r\n" "$path"
        printf "Host: %s\r\n" "$host"
        printf "User-Agent: %s\r\n" "$USER_AGENT"
        printf "Connection: close\r\n"
        printf "\r\n"
    } | openssl s_client -connect "$host:$port" -servername "$host" \
      $ssl_opts -timeout $DEFAULT_TIMEOUT > "$response_file" 2>"$error_file"

    # Check for connection errors
    if [ $? -ne 0 ]; then
        echo "Connection Failed: $host:$port" >&2
        echo "Possible reasons:" >&2
        grep -o "connect:.*\|SSL3_.*\|certificate.*" "$error_file" | sort -u >&2
        return 1
    fi

    # Check if response is empty
    if [ ! -s "$response_file" ]; then
        echo "Error: Server returned empty response" >&2
        return 1
    fi

    # Process response
    local header_end=$(grep -an $'^\r$' "$response_file" | head -1 | cut -d: -f1)
    if [ -z "$header_end" ]; then
        echo "Error: Invalid HTTP response format" >&2
        [ $verbose -eq 1 ] && head -c 200 "$response_file" >&2
        return 1
    fi

    # Output results
    if [ -n "$output_file" ]; then
        tail -n +$((header_end + 1)) "$response_file" > "$output_file"
    else
        tail -n +$((header_end + 1)) "$response_file"
    fi

    return 0
}

# Main execution
if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
    netget "$@"
    exit $?
fi