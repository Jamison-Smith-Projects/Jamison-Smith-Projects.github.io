#!/bin/bash
# pime-netget v1.3 - Fixed HTTPS response handling

# --- Configuration ---
VERSION="1.3"
USER_AGENT="pime-netget/$VERSION"
DEFAULT_TIMEOUT=30
MAX_REDIRECTS=5

# --- Helper Functions ---
show_help() {
    cat <<EOF
pime-netget v$VERSION - A curl-like implementation using OpenSSL

Usage:
  pime-netget [options...] <url>
  pime-netget <url> | bash

Options:
  -o, --output FILE    Write output to FILE
  -L, --location       Follow redirects
  -m, --max-time SEC   Operation timeout
  -v, --verbose        Show headers
  -s, --silent         Silent mode
  --help               Show this help
EOF
}

parse_url() {
    local url="$1"
    [[ "$url" =~ ^https?:// ]] || url="https://$url"
    
    local protocol="${url%%://*}"
    local rest="${url#*://}"
    local host_port="${rest%%/*}"
    local path="/${rest#*/}"

    local host="${host_port%:*}"
    local port="${host_port##*:}"

    # Set default ports
    if [ "$host_port" = "$port" ]; then
        [ "$protocol" = "http" ] && port=80
        [ "$protocol" = "https" ] && port=443
    fi

    echo "$protocol $host $port $path"
}

# --- Fixed Netget Function ---
netget() {
    local url="$1"
    local output_file="$2"
    local follow_redirects=0
    local timeout=$DEFAULT_TIMEOUT
    local verbose=0
    local silent=0
    local insecure=0

    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case "$1" in
            -o|--output) output_file="$2"; shift 2 ;;
            -L|--location) follow_redirects=1; shift ;;
            -m|--max-time) timeout="$2"; shift 2 ;;
            -v|--verbose) verbose=1; shift ;;
            -s|--silent) silent=1; shift ;;
            --insecure) insecure=1; shift ;;
            --help) show_help; return 0 ;;
            *) url="$1"; shift ;;
        esac
    done

    # Validate URL
    if [ -z "$url" ]; then
        [ $silent -eq 0 ] && echo "URL is required" >&2
        return 1
    fi

    # Parse URL
    local url_parts
    url_parts=$(parse_url "$url") || return 1
    read -r protocol host port path <<< "$url_parts"

    # Prepare SSL options
    local ssl_opts=""
    [ $insecure -eq 1 ] && ssl_opts="-verify_quiet -verify_return_error"

    # Create temp files
    local tmp_dir=$(mktemp -d)
    local tmp_out="$tmp_dir/response"
    local tmp_headers="$tmp_dir/headers"
    trap 'rm -rf "$tmp_dir"' EXIT

    # Make HTTPS request
    if [ "$protocol" = "https" ]; then
        {
            echo "GET $path HTTP/1.1"
            echo "Host: $host"
            echo "User-Agent: $USER_AGENT"
            echo "Connection: close"
            echo
        } | openssl s_client -connect "$host:$port" -servername "$host" \
          -quiet $ssl_opts -timeout "$timeout" > "$tmp_out" 2>/dev/null
    else
        echo "HTTP not implemented (use HTTPS)" >&2
        return 1
    fi

    # Split headers and body
    awk 'NR==1{if($2 >= 400){print > "/dev/stderr"; exit 1}}
         /^\r$/{getline; body=1; next} 
         body==1{print > "'"$tmp_dir/body"'"; next}
         {print > "'"$tmp_headers"'"}
        ' "$tmp_out" >/dev/null 2>&1

    # Check for valid response
    if [ ! -f "$tmp_dir/body" ] || [ ! -s "$tmp_out" ]; then
        [ $silent -eq 0 ] && echo "Error: Invalid server response" >&2
        return 1
    fi

    # Handle redirects
    if [ $follow_redirects -eq 1 ]; then
        local redirect_url=$(grep -i '^location:' "$tmp_headers" | head -1 | sed 's/^location:\s*//i' | tr -d '\r')
        if [ -n "$redirect_url" ]; then
            [ $verbose -eq 1 ] && echo "Redirecting to: $redirect_url" >&2
            netget --location --max-time "$timeout" "$redirect_url" "$output_file"
            return $?
        fi
    fi

    # Output results
    if [ -n "$output_file" ]; then
        cp "$tmp_dir/body" "$output_file"
    else
        cat "$tmp_dir/body"
    fi

    [ $verbose -eq 1 ] && cat "$tmp_headers" >&2
    return 0
}

# --- Main Execution ---
if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
    netget "$@"
    exit $?
else
    export -f netget
fi