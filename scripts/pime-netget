#!/bin/bash

# --- Configuration ---
VERSION="1.0"
USER_AGENT="pime-netget/$VERSION"
TIMEOUT=30

# --- Main Function ---
netget() {
    # Argument check
    if [ -z "$1" ]; then
        echo "Usage: pime-netget URL [OUTPUT_FILE]"
        return 1
    fi
    local url="$1"
    local output_file="$2"

    # Parse URL components
    local protocol="${url%%://*}"
    local host_port="${url#*://}"
    host_port="${host_port%%/*}"
    local path="${url#*://$host_port}"
    path="${path:-/}"

    local host="${host_port%:*}"
    local port="${host_port##*:}"

    # Set default ports
    if [ "$host_port" = "$port" ]; then
        if [ "$protocol" = "http" ]; then
            port=80
        elif [ "$protocol" = "https" ]; then
            port=443
        else
            echo "Error: Unsupported protocol $protocol" >&2
            return 1
        fi
    fi

    # Create temp files
    local tmp_response=$(mktemp)
    local tmp_body=$(mktemp)

    # Build HTTP request
    {
        echo "GET $path HTTP/1.1"
        echo "Host: $host"
        echo "User-Agent: $USER_AGENT"
        echo "Connection: close"
        echo
    } > "$tmp_body"

    # Make the request
    local response
    if [ "$protocol" = "https" ]; then
        response=$(openssl s_client -connect "$host:$port" -servername "$host" -quiet -timeout "$TIMEOUT" < "$tmp_body" 2>/dev/null)
    else
        # Try different netcat implementations
        local nc_command=""
        for cmd in nc netcat ncat; do
            if command -v "$cmd" >/dev/null 2>&1; then
                nc_command="$cmd"
                break
            fi
        done
        
        if [ -z "$nc_command" ]; then
            echo "Error: netcat not found (required for HTTP)" >&2
            rm -f "$tmp_response" "$tmp_body"
            return 1
        fi
        
        response=$("$nc_command" -w "$TIMEOUT" "$host" "$port" < "$tmp_body")
    fi

    # Check for empty response
    if [ -z "$response" ]; then
        echo "Error: No response from server" >&2
        rm -f "$tmp_response" "$tmp_body"
        return 1
    fi

    # Process response
    echo "$response" > "$tmp_response"
    local header_end=$(grep -n -m 1 '^$' "$tmp_response" | cut -d: -f1)
    if [ -z "$header_end" ]; then
        echo "Error: Invalid HTTP response" >&2
        rm -f "$tmp_response" "$tmp_body"
        return 1
    fi

    # Extract headers and body
    local headers=$(head -n "$header_end" "$tmp_response")
    local body_offset=$(awk -v n="$header_end" 'NR <= n { bytes += length($0) + 1 } END { print bytes }' "$tmp_response")

    # Check HTTP status
    local http_status=$(head -n 1 "$tmp_response" | awk '{print $2}')
    if [ "$http_status" -ge 400 ]; then
        echo "Error: HTTP $http_status" >&2
        echo "$headers" >&2
        rm -f "$tmp_response" "$tmp_body"
        return 1
    fi

    # Handle redirects
    if [[ "$http_status" =~ 30[12378] ]]; then
        local redirect_url=$(echo "$headers" | grep -i '^Location:' | head -1 | sed 's/^Location:\s*//i' | tr -d '\r')
        if [ -n "$redirect_url" ]; then
            echo "Following redirect to: $redirect_url" >&2
            rm -f "$tmp_response" "$tmp_body"
            netget "$redirect_url" "$output_file"
            return $?
        fi
    fi

    # Output the body
    if [ -z "$output_file" ]; then
        dd if="$tmp_response" bs=1 skip="$body_offset" status=none 2>/dev/null
    else
        dd if="$tmp_response" bs=1 skip="$body_offset" status=none 2>/dev/null > "$output_file"
    fi

    # Cleanup
    rm -f "$tmp_response" "$tmp_body"
}

# --- Main Execution ---
if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
    # If run as a script
    netget "$@"
else
    # If sourced as a library
    export -f netget
fi