#!/bin/bash
# pime-netget v2.1 - Robust HTTPS implementation

VERSION="2.1"
USER_AGENT="pime-netget/$VERSION"
DEFAULT_TIMEOUT=30

show_help() {
    cat <<EOF
pime-netget v$VERSION - A reliable HTTPS client

Usage:
  pime-netget [options] <url>
  
Options:
  -o FILE      Write output to FILE
  -L           Follow redirects
  -v           Verbose mode
  -k           Skip SSL verification
  --help       Show this help
EOF
}

# Enhanced URL parser with validation
parse_url() {
    local url="$1"
    
    # Ensure URL starts with https://
    if [[ ! "$url" =~ ^https:// ]]; then
        echo "Error: Only HTTPS URLs are supported" >&2
        return 1
    fi

    local host_port="${url#https://}"
    host_port="${host_port%%[/?]*}"
    local path="/${url#https://$host_port/}"
    
    local host="${host_port%:*}"
    local port="${host_port##*:}"
    [ "$port" = "$host_port" ] && port=443
    
    # Validate host
    if [[ ! "$host" =~ ^([a-zA-Z0-9]|[a-zA-Z0-9][a-zA-Z0-9-]*[a-zA-Z0-9])(\.([a-zA-Z0-9]|[a-zA-Z0-9][a-zA-Z0-9-]*[a-zA-Z0-9]))*$ ]]; then
        echo "Error: Invalid hostname '$host'" >&2
        return 1
    fi
    
    # Validate port
    if (( port < 1 || port > 65535 )); then
        echo "Error: Invalid port number '$port'" >&2
        return 1
    fi
    
    echo "$host $port $path"
}

# Main request function with proper error handling
netget() {
    local url="$1"
    local output_file="$2"
    local follow_redirects=0
    local verbose=0
    local insecure=0
    
    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case "$1" in
            -o) output_file="$2"; shift 2 ;;
            -L) follow_redirects=1; shift ;;
            -v) verbose=1; shift ;;
            -k) insecure=1; shift ;;
            --help) show_help; return 0 ;;
            *) url="$1"; shift ;;
        esac
    done

    [ -z "$url" ] && { show_help; return 1; }

    # Parse URL with validation
    local url_parts
    if ! url_parts=$(parse_url "$url"); then
        return 1
    fi
    read -r host port path <<< "$url_parts"

    # Prepare SSL options
    local ssl_opts="-quiet"
    [ $insecure -eq 1 ] && ssl_opts+=" -verify_quiet -verify_return_error"

    # Create temporary files
    local tmp_dir=$(mktemp -d)
    local response_file="$tmp_dir/response"
    local headers_file="$tmp_dir/headers"
    trap 'rm -rf "$tmp_dir"' EXIT

    # Build HTTP request
    {
        printf "GET %s HTTP/1.1\r\n" "$path"
        printf "Host: %s\r\n" "$host"
        printf "User-Agent: %s\r\n" "$USER_AGENT"
        printf "Accept: */*\r\n"
        printf "Connection: close\r\n"
        printf "\r\n"
    } | openssl s_client -connect "$host:$port" -servername "$host" \
      $ssl_opts -timeout $DEFAULT_TIMEOUT > "$response_file" 2>"$tmp_dir/error"

    # Check for connection errors
    if [ $? -ne 0 ]; then
        echo "Error: Failed to connect to $host:$port" >&2
        [ $verbose -eq 1 ] && cat "$tmp_dir/error" >&2
        return 1
    fi

    # Check if response is empty
    if [ ! -s "$response_file" ]; then
        echo "Error: Empty response from server" >&2
        return 1
    fi

    # Extract HTTP status line
    local status_line=$(head -1 "$response_file")
    if [[ ! "$status_line" =~ ^HTTP/1\.[01]\ [0-9]{3} ]]; then
        echo "Error: Invalid HTTP response (bad status line)" >&2
        [ $verbose -eq 1 ] && head -c 200 "$response_file" >&2
        return 1
    fi

    # Find header/body separation (empty line)
    local header_end=$(grep -an $'^\r$' "$response_file" | head -1 | cut -d: -f1)
    if [ -z "$header_end" ]; then
        echo "Error: Invalid HTTP headers (no header/body separation)" >&2
        [ $verbose -eq 1 ] && head -c 200 "$response_file" >&2
        return 1
    fi

    # Extract headers
    head -n "$header_end" "$response_file" > "$headers_file"

    # Extract HTTP status code
    local http_status=$(awk '{print $2}' <<< "$status_line")

    # Handle redirects
    if [[ "$http_status" =~ 30[12378] ]] && [ $follow_redirects -eq 1 ]; then
        local redirect_url=$(grep -i '^location:' "$headers_file" | head -1 | sed 's/^location:\s*//i' | tr -d '\r')
        if [ -n "$redirect_url" ]; then
            [ $verbose -eq 1 ] && echo "Following redirect to: $redirect_url" >&2
            netget -L "$redirect_url" "$@"
            return $?
        fi
    fi

    # Handle error status codes
    if [ "$http_status" -ge 400 ]; then
        echo "HTTP Error $http_status" >&2
        [ $verbose -eq 1 ] && cat "$headers_file" >&2
        return 1
    fi

    # Extract body (starting after header_end)
    local body_start=$((header_end + 1))
    
    # Output results
    if [ -n "$output_file" ]; then
        tail -n +$body_start "$response_file" > "$output_file"
    else
        tail -n +$body_start "$response_file"
    fi

    # Verbose output
    [ $verbose -eq 1 ] && {
        echo "HTTP Response:" >&2
        cat "$headers_file" >&2
        echo >&2
    }

    return 0
}

# Main execution
if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
    netget "$@"
    exit $?
fi