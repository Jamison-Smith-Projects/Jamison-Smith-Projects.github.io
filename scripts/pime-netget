#!/bin/bash

#!/bin/bash

url="$1"
host=$(echo "$url" | sed -E 's_https?://([^/]+).*_\1_')
path=$(echo "$url" | sed -E 's_https?://[^/]+(/.*)?_\1_')
path=${path:-/}

# Create temp files
tmp_response=$(mktemp)
tmp_body=$(mktemp)

# Fetch raw HTTP response using OpenSSL
{
    echo "GET $path HTTP/1.1"
    echo "Host: $host"
    echo "User-Agent: pimenetget/1.0"
    echo "Connection: close"
    echo
} | openssl s_client -quiet -connect "$host:443" 2>/dev/null > "$tmp_response"

# Find where headers end
header_end=$(grep -n -m 1 '^$' "$tmp_response" | cut -d: -f1)
if [ -z "$header_end" ]; then
    echo "Failed to parse HTTP response headers." >&2
    rm -f "$tmp_response" "$tmp_body"
    exit 1
fi

# Extract content length
content_length=$(sed -n 's/^Content-Length: //Ip' "$tmp_response" | tr -d '\r')

# Start byte of body
body_start=$((header_end + 1))
body_offset=$(awk "NR < $body_start { total += length(\$0) + 1 } END { print total }" "$tmp_response")

# Extract body with a progress bar
if [ -n "$content_length" ]; then
    echo "Downloading ($content_length bytes):"
else
    echo "Downloading (unknown size):"
fi

dd if="$tmp_response" bs=1 skip="$body_offset" status=none |
{
    count=0
    bar_size=50
    while IFS= read -r -n1 -d '' c || [ -n "$c" ]; do
        printf "%s" "$c" >> "$tmp_body"
        count=$((count + 1))

        if [ $((count % 1024)) -eq 0 ] && [ -n "$content_length" ]; then
            progress=$((count * bar_size / content_length))
            bar=$(printf "%-${bar_size}s" "" | tr ' ' '=' | cut -c1-$progress)
            printf "\r[%s>%*s] %3d%%" "$bar" $((bar_size - progress)) "" $((count * 100 / content_length))
        fi
    done
    echo ""
}

# Output result to stdout
cat "$tmp_body"

# Cleanup
rm -f "$tmp_response" "$tmp_body"