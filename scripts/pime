#!/bin/sh

# --- Configuration ---
REPO_LIST_FILE="$HOME/.pime/repo-list.json"
ALL_PACKAGES="$HOME/.pime/packages.json"
INSTALLED_LIST="$HOME/.pime/installed.txt"
VERSION_FILE="$HOME/.pimeversion"

# --- Ensure directories exist ---
mkdir -p "$HOME/.pime"

# --- Functions ---

show_help() {
    cat <<EOF
Pime - Lightweight Package Manager (v$(cat "$VERSION_FILE" 2>/dev/null || echo "unknown"))

Usage: pime install PACKAGE
       pime uninstall PACKAGE
       pime update
       pime list
       pime add-repo URL
       pime --help
       pime -u

Options:
  --help            Show this help message and exit.
  -u                Updates this program.
EOF
}

mark_installed() {
    pkg="$1"
    grep -qxF "$pkg" "$INSTALLED_LIST" 2>/dev/null || echo "$pkg" >> "$INSTALLED_LIST"
}

mark_uninstalled() {
    pkg="$1"
    if [ -f "$INSTALLED_LIST" ]; then
        grep -vxF "$pkg" "$INSTALLED_LIST" > "$INSTALLED_LIST.tmp" && mv "$INSTALLED_LIST.tmp" "$INSTALLED_LIST"
    fi
}

list_installed() {
    if [ ! -f "$INSTALLED_LIST" ] || [ ! -s "$INSTALLED_LIST" ]; then
        echo "No packages installed."
    else
        echo "Installed packages:"
        cat "$INSTALLED_LIST"
    fi
}

netget() {
    local url="$1"
    local protocol host port path tmp_response tmp_body header_end content_length
    local body_start body_offset count bar_size progress bar
    local response_code redirect_url
    
    # Extract URL components
    protocol="${url%%://*}"
    host_port="${url#*://}"
    host_port="${host_port%%/*}"
    path="${url#*://$host_port}"
    path="${path:-/}"
    
    host="${host_port%:*}"
    port="${host_port##*:}"
    
    # Set default ports
    if [[ "$host_port" == "$port" ]]; then
        if [[ "$protocol" == "http" ]]; then
            port=80
        elif [[ "$protocol" == "https" ]]; then
            port=443
        else
            echo "Error: Unsupported protocol $protocol" >&2
            return 1
        fi
    fi
    
    # Create temp files
    tmp_response=$(mktemp)
    tmp_body=$(mktemp)
    
    # Build the HTTP request
    {
        echo "GET $path HTTP/1.1"
        echo "Host: $host"
        echo "User-Agent: pimenetget/1.0"
        echo "Connection: close"
        echo
    } > "$tmp_body"
    
    # Make the request
    if [[ "$protocol" == "https" ]]; then
        openssl s_client -quiet -connect "$host:$port" -servername "$host" < "$tmp_body" 2>/dev/null > "$tmp_response"
    else
        # Try various netcat implementations
        local nc_command=""
        for cmd in nc netcat ncat; do
            if command -v "$cmd" >/dev/null 2>&1; then
                nc_command="$cmd"
                break
            fi
        done
        
        if [[ -z "$nc_command" ]]; then
            echo "Error: netcat not found (required for HTTP requests)" >&2
            rm -f "$tmp_response" "$tmp_body"
            return 1
        fi
        
        "$nc_command" "$host" "$port" < "$tmp_body" > "$tmp_response"
    fi
    
    # Check for valid response
    if [[ ! -s "$tmp_response" ]]; then
        echo "Error: No response from server" >&2
        rm -f "$tmp_response" "$tmp_body"
        return 1
    fi
    
    # Check HTTP response code
    response_code=$(head -n 1 "$tmp_response" | awk '{print $2}')
    if [[ "$response_code" == 30[123578] ]]; then
        redirect_url=$(grep -i '^Location:' "$tmp_response" | head -1 | sed 's/^Location:\s*//i' | tr -d '\r')
        if [[ -n "$redirect_url" ]]; then
            echo "Following redirect to: $redirect_url" >&2
            rm -f "$tmp_response" "$tmp_body"
            netget "$redirect_url"
            return $?
        fi
    elif [[ "$response_code" != 2* ]]; then
        echo "Error: HTTP $response_code" >&2
        head -n 10 "$tmp_response" >&2
        rm -f "$tmp_response" "$tmp_body"
        return 1
    fi
    
    # Process response
    header_end=$(grep -n -m 1 '^$' "$tmp_response" | cut -d: -f1)
    if [[ -z "$header_end" ]]; then
        echo "Error: Invalid HTTP response." >&2
        rm -f "$tmp_response" "$tmp_body"
        return 1
    fi
    
    content_length=$(sed -n 's/^Content-Length: //Ip' "$tmp_response" | tr -d '\r')
    body_offset=$(awk -v n="$header_end" 'NR <= n { bytes += length($0) + 1 } END { print bytes }' "$tmp_response")
    
    if [[ -n "$content_length" ]]; then
        echo "Downloading ($content_length bytes):" >&2
    else
        echo "Downloading (unknown size):" >&2
    fi
    
    # Stream the response body with progress bar
    dd if="$tmp_response" bs=1 skip="$body_offset" status=none 2>/dev/null | {
        count=0
        bar_size=50
        
        while IFS= read -r -n1 c; do
            printf "%s" "$c"
            count=$((count + 1))
            if [[ $((count % 1024)) -eq 0 ]] && [[ -n "$content_length" ]]; then
                progress=$((count * bar_size / content_length))
                bar=$(printf "%-${bar_size}s" "" | tr ' ' '=' | cut -c1-$progress)
                printf "\r[%s>%*s] %3d%%" "$bar" $((bar_size - progress)) "" $((count * 100 / content_length)) >&2
            fi
        done
        
        # Final progress update
        if [[ -n "$content_length" ]]; then
            printf "\r[%s] %3d%%\n" "$(printf "%-${bar_size}s" "" | tr ' ' '=')" 100 >&2
        else
            printf "\nDownload complete (%d bytes)\n" "$count" >&2
        fi
    }
    
    # Clean up
    rm -f "$tmp_response" "$tmp_body"
}

update_packages() {
    echo "Updating package list..."
    echo '{}' > "$ALL_PACKAGES"
    [ -f "$REPO_LIST_FILE" ] || echo '[]' > "$REPO_LIST_FILE"

    for repo in $(jq -r '.[]' "$REPO_LIST_FILE"); do
        echo "Fetching: $repo"
        data=$(netget "$repo")
        if [ -n "$data" ]; then
            echo "$data" | jq -s '.[0] * .[1]' "$ALL_PACKAGES" - > "$ALL_PACKAGES.tmp" && mv "$ALL_PACKAGES.tmp" "$ALL_PACKAGES"
        else
            echo "Warning: Could not fetch $repo" >&2
        fi
    done
    echo "Package list updated."
}

install_package() {
    pkg="$1"
    if [ ! -f "$ALL_PACKAGES" ]; then
        echo "Package list not found. Run 'pime update' first." >&2
        exit 1
    fi

    pkg_data=$(jq -r --arg pkg "$pkg" '.[$pkg]' "$ALL_PACKAGES")
    if [ "$pkg_data" = "null" ]; then
        echo "Package '$pkg' not found." >&2
        exit 1
    fi

    url=$(echo "$pkg_data" | jq -r '.INSTALLERURL')
    author=$(echo "$pkg_data" | jq -r '.PackageAuthor // "Unknown"')
    dependencies=$(echo "$pkg_data" | jq -r '.Dependencies[]?')
    binary_name=$(echo "$pkg_data" | jq -r '.InstalledBinary')

    [ "$binary_name" = "null" ] || [ -z "$binary_name" ] && binary_name="$pkg"

    for dep in $dependencies; do
        echo "Installing dependency: $dep"
        install_package "$dep"
    done

    echo "Installing $pkg from $url (by $author)"
    tmpfile=$(mktemp)
    netget "$url" > "$tmpfile" || { echo "Failed to download installer."; rm -f "$tmpfile"; exit 1; }
    chmod +x "$tmpfile"
    sh "$tmpfile"
    rm "$tmpfile"
    mark_installed "$pkg"
    echo "$pkg installed."
}

uninstall_package() {
    pkg="$1"
    echo "Attempting to uninstall package: $pkg"

    BIN_PATHS="/usr/bin /usr/local/bin /usr/sbin /usr/local/sbin"
    FOUND=0
    for path in $BIN_PATHS; do
        if [ -f "$path/$pkg" ]; then
            echo "Found $pkg in $path, removing..."
            sudo rm -f "$path/$pkg"
            FOUND=1
        fi
    done

    if [ -f "$HOME/.local/bin/$pkg" ]; then
        echo "Found $pkg in ~/.local/bin, removing..."
        rm -f "$HOME/.local/bin/$pkg"
        FOUND=1
    fi

    VERSION_FILE="$HOME/.pime/.${pkg}version"
    if [ -f "$VERSION_FILE" ]; then
        echo "Removing version file: $VERSION_FILE"
        rm -f "$VERSION_FILE"
    fi
    mark_uninstalled "$pkg"
    if [ "$FOUND" -eq 0 ]; then
        echo "Warning: No binary for '$pkg' found in standard locations."
    else
        echo "Package '$pkg' uninstalled successfully."
    fi
}

add_repo() {
    url="$1"
    [ -f "$REPO_LIST_FILE" ] || echo '[]' > "$REPO_LIST_FILE"
    if jq -e --arg url "$url" '.[] | select(. == $url)' "$REPO_LIST_FILE" >/dev/null; then
        echo "Repository already added."
    else
        jq --arg url "$url" '. + [$url]' "$REPO_LIST_FILE" > "$REPO_LIST_FILE.tmp" && mv "$REPO_LIST_FILE.tmp" "$REPO_LIST_FILE"
        echo "Repository added."
    fi
}

update_bootstrapper() {
    cd "$HOME" || exit
    mkdir -p .pimebin
    cd .pimebin || exit
    netget https://jamisonsmith.is-a.dev/scripts/updaters/pime-updater > pime-updater
    chmod +x pime-updater
    ./pime-updater
    rm -rf .pimebin
    exit 0
}

# --- Main ---
case "$1" in
    --help)
        show_help
        ;;
    list)
        list_installed
        ;;
    update)
        update_packages
        ;;
    install)
        if [ -z "$2" ]; then
            echo "Error: Missing package name for install." >&2
            exit 1
        fi
        install_package "$2"
        ;;
    uninstall)
        if [ -z "$2" ]; then
            echo "Error: Missing package name for uninstall." >&2
            exit 1
        fi
        uninstall_package "$2"
        ;;
    add-repo)
        if [ -z "$2" ]; then
            echo "Error: Missing URL for add-repo." >&2
            exit 1
        fi
        add_repo "$2"
        ;;
    -u)
        update_bootstrapper
        ;;
    *)
        echo "Error: Unknown command '$1'" >&2
        show_help
        exit 1
        ;;
esac